<h1>
  CSS <img src="./assets/css.svg" width="40" height="40" alt="CSS logo"/>
</h1>

<h2>Найпопулярніші запитання та відповіді на співбесіді з CSS</h2>

<details>
<summary>1. Що таке CSS?</summary>

- CSS (Cascading Style Sheets) — це мова стилів, яка використовується для опису зовнішнього вигляду веб-сторінок, створених за допомогою HTML або XML.
</details>

<details>
<summary>2. Що таке каскадність у CSS??</summary>

- Каскадність у CSS — це механізм, який визначає, як застосовуються стилі до елементів веб-сторінки, якщо для одного елемента задано кілька різних стилів із різних джерел або рівнів. Вона дозволяє браузеру вирішити, які стилі будуть мати вищий пріоритет і застосовуватися в кінцевому результаті.
</details>

<details>
<summary>3. Які є способи підключення CSS до HTML-документу?</summary>

- Вбудовані стилі (inline) — напряму в HTML-тегах через атрибут `style`.
- Внутрішні стилі — у секції `<style>...</style> ` всередині HTML-документа.
- Зовнішні стилі — у CSS-файлах, підключених через `<link rel=”stylesheet” href=”styles.css”>` або `@import`.

</details>

<details>
<summary>4. Що таке CSS-селектори? Наведіть приклади.</summary>

- CSS-селектори використовуються для вибору HTML-елементів, до яких застосовуються стилі.

- **Приклади:**

  - За тегом: `h1 { color: red; }`
  - За класом: `.button { background: blue; }`
  - За ID: `#header { padding: 10px; }`

- **Комбіновані:**

  - Дочірні: `ul > li { margin: 5px; }`
  - Нащадки: `div p { font-size: 14px; }`
  - Атрибути: `[type="text"] { border: 1px solid gray; }`

- **Псевдокласи:**

  - `a:hover { color: green; }`
  - `:nth-child(2) { font-weight: bold; }`

- **Псевдоелементи:**

  - `p::first-line { text-transform: uppercase; }`

</details>

<details>
<summary>5. Як працює наслідування в CSS?</summary>

- Наслідування в CSS дозволяє деяким властивостям автоматично передаватися від батьківського елемента до дочірніх.

- **Особливості:**

1. Автоматично наслідуються тільки текстові та декоративні властивості:

- `color`, `font`, `visibility`, `line-height` тощо.

2. Не наслідуються автоматично властивості, що впливають на коробку (box model):

- `margin`, `padding`, `border`, `width`, `heigh`t тощо.

- **Контроль наслідування:**

1. **Примусове наслідування:** використовуйте значення inherit.

   ```css
   p {
     border: inherit;
   }
   ```

2. **Відміна наслідування:** значення initial скидає властивість до початкового (згідно стандарту).

   ```css
   p {
     color: initial;
   }
   ```

</details>

<details>

<summary>6. Що таке «модель коробки» (box model) в CSS і як її можна змінити?</summary>

- «Модель коробки» (box model) визначає, як розміри елемента розраховуються в CSS. Вона складається з:

  - **Content:** Вміст елемента (текст, зображення).
  - **Padding:** Внутрішній відступ між вмістом і рамкою.
  - **Border:** Рамка навколо padding.
  - **Margin:** Зовнішній відступ між елементом і сусідніми елементами.

- Розрахунок ширини та висоти:

  - За замовчуванням:

  ```css
  Width/Height = Content + Padding + Border
  ```

- Зміна моделі коробки:

  - Використовуйте властивість box-sizing:

1. content-box (за замовчуванням):

- Ширина/висота включає лише вміст. Padding і border додаються до загального розміру.

  ```css
  box-sizing: content-box;
  ```

2. border-box:

- Ширина/висота включають вміст, padding і border (зручніше для макетів).

  ```css
  box-sizing: border-box;
  ```

- Приклад:

  ```css
  * {
    box-sizing: border-box;
  }
  ```

  - Це допомагає уникнути помилок у розмітці.
  </details>

<details>
<summary>7. У чому різниця між margin і padding?</summary>

- Різниця між margin і padding:

1. Розташування:

   - `margin` створює зовнішній відступ між елементом і сусідніми елементами.
   - `padding` створює внутрішній відступ між вмістом елемента і його рамкою (border).

2. Вплив на фон:

   - `margin` не впливає на фон елемента; простір залишається прозорим.
   - `padding` є частиною елемента, тому фон розтягується на область padding.

3. Колізія (margin collapsing):

   - `margin` сусідніх блоків може "зливатися" в один (найбільший).
   - `padding` не зливається; завжди додається до внутрішнього простору.

- Приклад:

  ```css
  div {
    margin: 20px; /* Відступ від інших елементів */
    padding: 20px; /* Відступ між вмістом і рамкою */
    background-color: lightblue;
  }
  ```

</details>

<details>
<summary>8. Що таке Flexbox?</summary>

- Flexbox (Flexible Box Layout) — це CSS-модель розташування елементів, яка забезпечує гнучке вирівнювання та розподіл простору в межах контейнера, навіть якщо розміри елементів невідомі або змінюються.

- **Основні поняття:**

  - **Flex-контейнер:** Батьківський елемент, на який застосовується `display: flex;`.
  - **Flex-елементи:** Дочірні елементи flex-контейнера.

- **Основні властивості Flexbox:**

1. Для контейнера:

   - `flex-direction`: Напрямок розташування елементів (`row`, `row-reverse`, `column`, `column-reverse`).
   - `justify-content`: Горизонтальне вирівнювання елементів (`flex-start`, `center`, `space-between`, `space-around`, `space-evenly`).
   - `align-items`: Вертикальне вирівнювання елементів (`stretch`, `center`, `flex-start`, `flex-end`, `baseline`).
   - `align-content`: Вирівнювання рядків у багаторядковому контейнері (`stretch`, `center`, `space-between`).
   - `flex-wrap`: Дозволяє елементам переноситися (`nowrap`, `wrap`, `wrap-reverse`).

2. Для елементів:

   - `flex-grow`: Як елемент збільшується вільним простором.
   - `flex-shrink`: Як елемент зменшується при нестачі простору.
   - `flex-basis`: Базовий розмір елемента перед розподілом простору.
   - `align-self`: Вирівнювання конкретного елемента всередині контейнера.

- Приклад:

  ```css
  .container {
    display: flex;
    justify-content: center;
    align-items: center;
  }

  .item {
    flex: 1; /* Рівний розподіл простору */
  }
  ```

</details>

<details>
<summary>9. Що таке Grid?</summary>

- CSS Grid — це потужна система розмітки, яка дозволяє створювати двовимірні сітки для розташування елементів як по горизонталі, так і по вертикалі.

- **Основні поняття:**

  - **Grid-контейнер:** Елемент, на який застосовується `display: grid;`.
  - **Grid-елементи:** Дочірні елементи grid-контейнера.
  - **Лінії сітки:** Вертикальні та горизонтальні межі, що ділять сітку на осередки.
  - **Треки:** Рядки (`rows`) і колонки (`columns`).
  - **Області:** Прямокутні зони, об'єднані з кількох осередків.

- **Основні властивості Grid:**

1. Для контейнера:

- `grid-template-rows`, `grid-template-columns`: Задають кількість і розміри рядків та колонок.
- `grid-template-areas`: Іменовані області для організації елементів.
- `gap` (або `row-gap/column-gap`): Відступи між рядками та колонками.
- `justify-items`, `align-items`: Вирівнювання елементів у клітинках.
- `justify-content`, `align-content`: Вирівнювання всієї сітки в контейнері.

2. Для елементів:

- `grid-column`, `grid-row`: Позиціювання по колонках і рядках.
- `grid-area`: Розміщення в іменованій області.
- `place-self`: Індивідуальне вирівнювання елемента.

- Приклад:

  ```css
  .container {
    display: grid;
    grid-template-columns: 1fr 2fr; /* Дві колонки: 1 частина та 2 частини */
    grid-template-rows: 100px auto; /* Рядок фіксованої висоти і автоматичний */
    gap: 10px;
  }

  .item1 {
    grid-column: 1 / 3; /* Займає дві колонки */
  }

  .item2 {
    grid-row: 2; /* Розташований у другому рядку */
  }
  ```

</details>

<details>
<summary>10. Що таке медіазапити та як їх використовувати?</summary>

- Медіазапити — це умови, які дозволяють застосовувати різні стилі в залежності від характеристик пристрою (наприклад, розміру екрану, орієнтації). Вони використовуються в CSS через правило @media.

- Приклад медіазапиту для адаптивного дизайну:

  ```css
  /* Стилі для мобільних пристроїв */
  @media (max-width: 768px) {
    body {
      background-color: lightblue;
    }
  }

  /* Стилі для десктопів */
  @media (min-width: 769px) {
    body {
      background-color: lightgreen;
    }
  }
  ```

</details>

<details>
<summary>11. Як можна приховати елемент за допомогою CSS?</summary>

- Щоб приховати елемент за допомогою CSS, можна використовувати:
  - `display: none;` — видаляє елемент з потоку документа. Він не займає місця на сторінці і з ним не можна взаємодіяти.
  - `visibility: hidden;` — елемент стає невидимим, але зберігає своє місце на сторінці.
  - `opacity: 0;` — робить елемент прозорим, але він залишається видимим і займає місце на сторінці.

</details>

<details>
<summary>12. Як можна зробити лого посередині екрана?</summary>

- Щоб розмістити лого посередині екрана, можна використати такі способи:

1. Flexbox:

   ```css
   body,
   html {
     height: 100%;
     margin: 0;
     display: flex;
     justify-content: center;
     align-items: center;
   }

   .logo {
     /* стилі лого */
   }
   ```

2. Grid:

   ```css
   body,
   html {
     height: 100%;
     margin: 0;
     display: grid;
     place-items: center;
   }

   .logo {
     /* стилі лого */
   }
   ```

3. Absolute позиціювання:

   ```css
   body,
   html {
     height: 100%;
     margin: 0;
     position: relative;
   }

   .logo {
     position: absolute;
     top: 50%;
     left: 50%;
     transform: translate(-50%, -50%);
   }
   ```

</details>

<details>
<summary>13. Як розмістити хрестик для закриття справа зверху елемента?</summary>

- Щоб розмістити хрестик для закриття в правому верхньому куті елемента, можна використати абсолютне позиціювання:

  ```css
  .container {
    position: relative; /* щоб хрестик позиціонувався відносно контейнера */
  }

  .close-btn {
    position: absolute;
    top: 10px; /* відстань від верхнього краю */
    right: 10px; /* відстань від правого краю */
    cursor: pointer; /* щоб курсор змінювався при наведенні */
  }
  ```

  ```html
  <div class="container">
    <div class="close-btn">&times;</div>
    <!-- інший контент -->
  </div>
  ```

</details>

<details>
<summary>14. Як зробити останній елемент списку червоним, незалежно від довжини списку без JS?</summary>

- Щоб зробити останній елемент списку червоним без JavaScript, можна використати псевдоклас `:last-child:`.
- Це правило зробить останній елемент у будь-якому списку (незалежно від його довжини) червоним.

  ```css
  ul li:last-child {
    color: red;
  }
  ```

- Це правило зробить останній елемент у будь-якому списку (незалежно від його довжини) червоним.

</details>

<details>
<summary>15. Які є можливості задати колір?</summary>

- У CSS є кілька способів задати колір:

1. Ім’я кольору:

   ```css
   color: red;
   ```

2. Шістнадцятковий код:

   ```css
   color: #ff0000; /* червоний */
   ```

3. RGB (Red, Green, Blue):

   ```css
   color: rgb(255, 0, 0); /* червоний */
   ```

4. RGBA (Red, Green, Blue, Alpha):

   ```css
   color: rgba(255, 0, 0, 0.5); /* червоний з прозорістю */
   ```

5. HSL (Hue, Saturation, Lightness):

   ```css
   color: hsl(0, 100%, 50%); /* червоний */
   ```

6. HSLA (Hue, Saturation, Lightness, Alpha):

   ```css
   color: hsla(0, 100%, 50%, 0.5); /* червоний з прозорістю */
   ```

7. Ключові слова прозорості:

   ```css
   color: transparent; /* прозорий */
   ```

- Ці способи дозволяють вибирати колір за різними параметрами: від прямого опису кольору до використання прозорості або відтінків.

</details>

<details>
<summary>16. Що таке z-index? Чи кожен елемент його має?</summary>

- `z-index` — це властивість CSS, яка визначає порядок накладання елементів по осі Z (глибина, перетин елементів). Елементи з більшим `z-index` накладаються поверх елементів з меншим значенням.

- **Особливості:**

1. Тільки для позиційованих елементів: `z-index` працює, якщо елемент має `position`: `relative`, `absolute`, `fixed` або `sticky`. Без цього `z-index` ігнорується.

2. Значення за замовчуванням: Якщо `z-index` не задано, значення за замовчуванням — `auto`. У такому випадку порядок накладання визначається порядком у DOM.

3. Може бути від’ємним: Елементи з від’ємним `z-index` можуть накладатися позаду батьківських елементів.

- Приклад:

  ```css
  .div1 {
    position: relative;
    z-index: 10; /* цей елемент буде поверх */
  }

  .div2 {
    position: relative;
    z-index: 5; /* цей елемент буде під div1 */
  }
  ```

</details>

<details>
<summary>17. Які переваги і недоліки використання CSS-препроцесорів?</summary>

- **Переваги CSS-препроцесорів:**

1. **Змінні:** Легко створювати глобальні змінні для кольорів, шрифтів, розмірів.

   ```css
   $primary-color: #3498db;

   body {
     color: $primary-color;
   }
   ```

2. **Вкладеність:** Зручний запис стилів для вкладених елементів.

   ```css
   nav {
     ul {
       li {
         a {
           color: #000;
         }
       }
     }
   }
   ```

3. **Міксіни:** Повторно використовувані блоки коду.

   ```css
   @mixin flex-center {
     display: flex;
     justify-content: center;
     align-items: center;
   }

   div {
     @include flex-center;
   }
   ```

4. **Функції:** Обчислення прямо в стилях.

   ```css
   width: calc(100% - 50px);
   ```

5. **Управління кодом:** Імпорт окремих файлів (`@import`), що полегшує підтримку великого проекту.

- **Недоліки CSS-препроцесорів:**

1. **Складність налаштування:** Потрібно встановлювати додаткові інструменти (наприклад, компілятор для SCSS або LESS).

2. **Продуктивність:** Велика кількість вкладеностей або міксінів може ускладнити генерований CSS і вплинути на швидкість.

3. **Залежність:** Знання синтаксису препроцесора необов'язково підтримується усіма розробниками в команді.

4. **Дебагінг:** Згенерований CSS може бути складніше дебажити, якщо немає source maps.

- Використання залежить від розміру проекту та необхідності складних стилів. Для великих проектів переваги переважують недоліки.

</details>

<details>
<summary>18. Для чого існують різні рівні заголовків, якщо розмір можна встановити стилями?</summary>

- Рівні заголовків (`<h1> – <h6>`) мають інше призначення, окрім визначення розміру. Їхня основна функція — структуризація контенту для семантики та доступності:

1. **Семантика:** Заголовки формують ієрархію документа. Наприклад:

`<h1>` — головна тема сторінки.
`<h2>` — підрозділ теми `<h1>`.
`<h3>` — підрозділ `<h2>`, і так далі.

2. **SEO:** Пошукові системи (Google, Bing) використовують заголовки для розуміння структури і змісту сторінки. Коректна ієрархія заголовків підвищує релевантність сторінки.

3. **Доступність:** Екранні читачі для людей із порушеннями зору використовують заголовки для навігації по сторінці.

4. **Стандарти:** Використання заголовків за призначенням робить код зрозумілим для інших розробників.

- Розмір заголовків можна стилізувати за допомогою CSS, але правильне використання тегів забезпечує краще розуміння і роботу сторінки.

</details>

<details>
<summary>19. Які є варіанти позиціонування елемента на сторінці?</summary>

- У CSS є кілька варіантів позиціонування елементів:

1. `static` (за замовчуванням):
   Елемент розташовується в потоці документа відповідно до порядку в HTML. Немає можливості змінювати його положення через властивості top, right, bottom, left.

2. `relative`:
   Елемент залишається в потоці документа, але його положення можна змінити відносно початкової позиції за допомогою top, right, bottom, left.

3. `absolute`:
   Елемент вилучається з потоку і позиціонується відносно найближчого батьківського елемента з позиціюванням (relative, absolute, fixed). Якщо такого немає, то відносно всього документа.

4. `fixed`:
   Елемент вилучається з потоку і закріплюється відносно вікна браузера. Його положення не змінюється при прокручуванні сторінки.

5. `sticky`:
   Комбінація relative і fixed. Елемент позиціонується відносно потоку документа, поки не досягне заданого порогу (top, bottom тощо), після чого "прилипає" до цього порогу при прокручуванні.

6. `inherit`, `initial`, `unset`:

- inherit — наслідує значення від батьківського елемента.
- initial — скидає до значення за замовчуванням (static).
- unset — застосовує inherit або initial залежно від контексту.

- Кожен варіант використовується залежно від завдання: від базового розташування до складного позиціонування в макетах.

</details>

<details>
<summary>20. Які бувають види display? Який використовуєте найчастіше? У чому особливість inline-block?</summary>

- Основні види display в CSS:

1. `block`:

   - Елемент займає всю ширину батьківського контейнера.
   - Починається з нового рядка.
   - Можна задавати ширину, висоту, внутрішні/зовнішні відступи.
   - Приклад: `<div>`, `<p>`.

2. `inline`:

   - Елемент розташовується в одному рядку з іншими елементами.
   - Неможливо задавати ширину та висоту.
   - Відступи (margin/padding) впливають лише на внутрішній простір.
   - Приклад: `<span>`, `<a>`.

3. `inline-block`:

   - Поєднує особливості block і inline.
   - Елемент розташовується в рядку, але дозволяє задавати ширину, висоту, відступи.
   - Зручний для створення кнопок, тегів.

4. `flex`:

   - Відображає елемент як контейнер для гнучкого компонування дочірніх елементів.
   - Використовується для вирівнювання та розподілу простору між елементами.

5. `grid`:

   - Задає контейнер для компонування в двовимірній сітці.
   - Зручний для складних макетів.

6. `none`:

   - Елемент не відображається на сторінці.

7. `inline-flex` / `inline-grid`:

   - Аналогічні flex і grid, але зберігають властивості inline.

8. `table` / `table-row` / `table-cell`:

   - Елементи імітують поведінку таблиць HTML.

- **Найчастіше використовується:**

  - block, inline-block, flex, і grid — залежно від завдань.
  - inline-block популярний для створення кнопок або елементів меню, які потрібно розташувати в рядок, але контролювати їх розміри.

- **Особливість inline-block:**

  - Елементи розташовуються в рядок, як inline, але поводяться як block, дозволяючи задавати ширину, висоту, та всі відступи.
  - Проблема: між елементами може з’явитися проміжок (через пробіли в HTML).

- Виправляється:
  - Видаленням пробілів у коді.
  - Встановленням font-size: 0 для батьківського контейнера.

</details>
