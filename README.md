<h1>
  CSS <img src="./assets/css.svg" width="40" height="40" alt="CSS logo"/>
</h1>

<h2>Найпопулярніші запитання та відповіді на співбесіді з CSS</h2>

<details>
<summary>1. Що таке CSS? І навіщо він використовується?</summary>

#### CSS

- CSS (Cascading Style Sheets) — це мова стилів для опису вигляду веб-сторінок. Використовується для розмітки елементів на сторінці, таких як шрифти, кольори, відступи, позиціонування та інші візуальні аспекти. CSS дозволяє відокремити контент (HTML) від стилів, що полегшує підтримку та зміну вигляду сайту.

</details>

<details>
<summary>2. Що таке каскадність у CSS??</summary>

#### CSS

- Каскадність у CSS — це механізм, який визначає, як застосовуються стилі до елементів веб-сторінки, якщо для одного елемента задано кілька різних стилів із різних джерел або рівнів. Вона дозволяє браузеру вирішити, які стилі будуть мати вищий пріоритет і застосовуватися в кінцевому результаті.
</details>

<details>
<summary>3. Які є способи підключення CSS до HTML-документу?</summary>

#### CSS

- Вбудовані стилі (inline) — напряму в HTML-тегах через атрибут `style`.
- Внутрішні стилі — у секції `<style>...</style> ` всередині HTML-документа.
- Зовнішні стилі — у CSS-файлах, підключених через `<link rel=”stylesheet” href=”styles.css”>` або `@import`.

</details>

<details>
<summary>4. Що таке CSS-селектори? Наведіть приклади.</summary>

#### CSS

- CSS-селектори використовуються для вибору HTML-елементів, до яких застосовуються стилі.

- **Приклади:**

  - За тегом: `h1 { color: red; }`
  - За класом: `.button { background: blue; }`
  - За ID: `#header { padding: 10px; }`

- **Комбіновані:**

  - Дочірні: `ul > li { margin: 5px; }`
  - Нащадки: `div p { font-size: 14px; }`
  - Атрибути: `[type="text"] { border: 1px solid gray; }`

- **Псевдокласи:**

  - `a:hover { color: green; }`
  - `:nth-child(2) { font-weight: bold; }`

- **Псевдоелементи:**

  - `p::first-line { text-transform: uppercase; }`

</details>

<details>
<summary>5. Як працює наслідування в CSS?</summary>

#### CSS

- Наслідування в CSS дозволяє деяким властивостям автоматично передаватися від батьківського елемента до дочірніх.

- **Особливості:**

1. Автоматично наслідуються тільки текстові та декоративні властивості:

- `color`, `font`, `visibility`, `line-height` тощо.

2. Не наслідуються автоматично властивості, що впливають на коробку (box model):

- `margin`, `padding`, `border`, `width`, `heigh`t тощо.

- **Контроль наслідування:**

1. **Примусове наслідування:** використовуйте значення inherit.

   ```css
   p {
     border: inherit;
   }
   ```

2. **Відміна наслідування:** значення initial скидає властивість до початкового (згідно стандарту).

   ```css
   p {
     color: initial;
   }
   ```

</details>

<details>

<summary>6. Що таке «модель коробки» (box model) в CSS і як її можна змінити?</summary>

#### CSS

- «Модель коробки» (box model) визначає, як розміри елемента розраховуються в CSS. Вона складається з:

  - **Content:** Вміст елемента (текст, зображення).
  - **Padding:** Внутрішній відступ між вмістом і рамкою.
  - **Border:** Рамка навколо padding.
  - **Margin:** Зовнішній відступ між елементом і сусідніми елементами.

- Розрахунок ширини та висоти:

  - За замовчуванням:

  ```css
  Width/Height = Content + Padding + Border
  ```

- Зміна моделі коробки:

  - Використовуйте властивість box-sizing:

1. content-box (за замовчуванням):

- Ширина/висота включає лише вміст. Padding і border додаються до загального розміру.

  ```css
  box-sizing: content-box;
  ```

2. border-box:

- Ширина/висота включають вміст, padding і border (зручніше для макетів).

  ```css
  box-sizing: border-box;
  ```

- Приклад:

  ```css
  * {
    box-sizing: border-box;
  }
  ```

  - Це допомагає уникнути помилок у розмітці.

</details>

<details>
<summary>7. У чому різниця між margin і padding?</summary>

#### CSS

- Різниця між margin і padding:

1. Розташування:

   - `margin` створює зовнішній відступ між елементом і сусідніми елементами.
   - `padding` створює внутрішній відступ між вмістом елемента і його рамкою (border).

2. Вплив на фон:

   - `margin` не впливає на фон елемента; простір залишається прозорим.
   - `padding` є частиною елемента, тому фон розтягується на область padding.

3. Колізія (margin collapsing):

   - `margin` сусідніх блоків може "зливатися" в один (найбільший).
   - `padding` не зливається; завжди додається до внутрішнього простору.

- Приклад:

  ```css
  div {
    margin: 20px; /* Відступ від інших елементів */
    padding: 20px; /* Відступ між вмістом і рамкою */
    background-color: lightblue;
  }
  ```

</details>

<details>
<summary>8. Що таке Flexbox?</summary>

#### CSS

- Flexbox (Flexible Box Layout) — це CSS-модель розташування елементів, яка забезпечує гнучке вирівнювання та розподіл простору в межах контейнера, навіть якщо розміри елементів невідомі або змінюються.

- **Основні поняття:**

  - **Flex-контейнер:** Батьківський елемент, на який застосовується `display: flex;`.
  - **Flex-елементи:** Дочірні елементи flex-контейнера.

- **Основні властивості Flexbox:**

1. Для контейнера:

   - `flex-direction`: Напрямок розташування елементів (`row`, `row-reverse`, `column`, `column-reverse`).
   - `justify-content`: Горизонтальне вирівнювання елементів (`flex-start`, `center`, `space-between`, `space-around`, `space-evenly`).
   - `align-items`: Вертикальне вирівнювання елементів (`stretch`, `center`, `flex-start`, `flex-end`, `baseline`).
   - `align-content`: Вирівнювання рядків у багаторядковому контейнері (`stretch`, `center`, `space-between`).
   - `flex-wrap`: Дозволяє елементам переноситися (`nowrap`, `wrap`, `wrap-reverse`).

2. Для елементів:

   - `flex-grow`: Як елемент збільшується вільним простором.
   - `flex-shrink`: Як елемент зменшується при нестачі простору.
   - `flex-basis`: Базовий розмір елемента перед розподілом простору.
   - `align-self`: Вирівнювання конкретного елемента всередині контейнера.

- Приклад:

  ```css
  .container {
    display: flex;
    justify-content: center;
    align-items: center;
  }

  .item {
    flex: 1; /* Рівний розподіл простору */
  }
  ```

</details>

<details>
<summary>9. Що таке Grid?</summary>

#### CSS

- CSS Grid — це потужна система розмітки, яка дозволяє створювати двовимірні сітки для розташування елементів як по горизонталі, так і по вертикалі.

- **Основні поняття:**

  - **Grid-контейнер:** Елемент, на який застосовується `display: grid;`.
  - **Grid-елементи:** Дочірні елементи grid-контейнера.
  - **Лінії сітки:** Вертикальні та горизонтальні межі, що ділять сітку на осередки.
  - **Треки:** Рядки (`rows`) і колонки (`columns`).
  - **Області:** Прямокутні зони, об'єднані з кількох осередків.

- **Основні властивості Grid:**

1. Для контейнера:

- `grid-template-rows`, `grid-template-columns`: Задають кількість і розміри рядків та колонок.
- `grid-template-areas`: Іменовані області для організації елементів.
- `gap` (або `row-gap/column-gap`): Відступи між рядками та колонками.
- `justify-items`, `align-items`: Вирівнювання елементів у клітинках.
- `justify-content`, `align-content`: Вирівнювання всієї сітки в контейнері.

2. Для елементів:

- `grid-column`, `grid-row`: Позиціювання по колонках і рядках.
- `grid-area`: Розміщення в іменованій області.
- `place-self`: Індивідуальне вирівнювання елемента.

- Приклад:

  ```css
  .container {
    display: grid;
    grid-template-columns: 1fr 2fr; /* Дві колонки: 1 частина та 2 частини */
    grid-template-rows: 100px auto; /* Рядок фіксованої висоти і автоматичний */
    gap: 10px;
  }

  .item1 {
    grid-column: 1 / 3; /* Займає дві колонки */
  }

  .item2 {
    grid-row: 2; /* Розташований у другому рядку */
  }
  ```

</details>

<details>
<summary>10. Що таке медіазапити та як їх використовувати?</summary>

#### CSS

- Медіазапити — це умови, які дозволяють застосовувати різні стилі в залежності від характеристик пристрою (наприклад, розміру екрану, орієнтації). Вони використовуються в CSS через правило @media.

- Приклад медіазапиту для адаптивного дизайну:

  ```css
  /* Стилі для мобільних пристроїв */
  @media (max-width: 768px) {
    body {
      background-color: lightblue;
    }
  }

  /* Стилі для десктопів */
  @media (min-width: 769px) {
    body {
      background-color: lightgreen;
    }
  }
  ```

</details>

<details>
<summary>11. Як можна приховати елемент за допомогою CSS?</summary>

#### CSS

- Щоб приховати елемент за допомогою CSS, можна використовувати:
  - `display: none;` — видаляє елемент з потоку документа. Він не займає місця на сторінці і з ним не можна взаємодіяти.
  - `visibility: hidden;` — елемент стає невидимим, але зберігає своє місце на сторінці.
  - `opacity: 0;` — робить елемент прозорим, але він залишається видимим і займає місце на сторінці.

</details>

<details>
<summary>12. Як можна зробити лого посередині екрана?</summary>

#### CSS

- Щоб розмістити лого посередині екрана, можна використати такі способи:

1. Flexbox:

   ```css
   body,
   html {
     height: 100%;
     margin: 0;
     display: flex;
     justify-content: center;
     align-items: center;
   }

   .logo {
     /* стилі лого */
   }
   ```

2. Grid:

   ```css
   body,
   html {
     height: 100%;
     margin: 0;
     display: grid;
     place-items: center;
   }

   .logo {
     /* стилі лого */
   }
   ```

3. Absolute позиціювання:

   ```css
   body,
   html {
     height: 100%;
     margin: 0;
     position: relative;
   }

   .logo {
     position: absolute;
     top: 50%;
     left: 50%;
     transform: translate(-50%, -50%);
   }
   ```

</details>

<details>
<summary>13. Як розмістити хрестик для закриття справа зверху елемента?</summary>

#### CSS

- Щоб розмістити хрестик для закриття в правому верхньому куті елемента, можна використати абсолютне позиціювання:

  ```css
  .container {
    position: relative; /* щоб хрестик позиціонувався відносно контейнера */
  }

  .close-btn {
    position: absolute;
    top: 10px; /* відстань від верхнього краю */
    right: 10px; /* відстань від правого краю */
    cursor: pointer; /* щоб курсор змінювався при наведенні */
  }
  ```

  ```html
  <div class="container">
    <div class="close-btn">&times;</div>
    <!-- інший контент -->
  </div>
  ```

</details>

<details>
<summary>14. Як зробити останній елемент списку червоним, незалежно від довжини списку без JS?</summary>

#### CSS

- Щоб зробити останній елемент списку червоним без JavaScript, можна використати псевдоклас `:last-child:`.
- Це правило зробить останній елемент у будь-якому списку (незалежно від його довжини) червоним.

  ```css
  ul li:last-child {
    color: red;
  }
  ```

- Це правило зробить останній елемент у будь-якому списку (незалежно від його довжини) червоним.

</details>

<details>
<summary>15. Які є можливості задати колір?</summary>

#### CSS

- У CSS є кілька способів задати колір:

1. Ім’я кольору:

   ```css
   color: red;
   ```

2. Шістнадцятковий код:

   ```css
   color: #ff0000; /* червоний */
   ```

3. RGB (Red, Green, Blue):

   ```css
   color: rgb(255, 0, 0); /* червоний */
   ```

4. RGBA (Red, Green, Blue, Alpha):

   ```css
   color: rgba(255, 0, 0, 0.5); /* червоний з прозорістю */
   ```

5. HSL (Hue, Saturation, Lightness):

   ```css
   color: hsl(0, 100%, 50%); /* червоний */
   ```

6. HSLA (Hue, Saturation, Lightness, Alpha):

   ```css
   color: hsla(0, 100%, 50%, 0.5); /* червоний з прозорістю */
   ```

7. Ключові слова прозорості:

   ```css
   color: transparent; /* прозорий */
   ```

- Ці способи дозволяють вибирати колір за різними параметрами: від прямого опису кольору до використання прозорості або відтінків.

</details>

<details>
<summary>16. Що таке z-index? Чи кожен елемент його має?</summary>

#### CSS

- `z-index` — це властивість CSS, яка визначає порядок накладання елементів по осі Z (глибина, перетин елементів). Елементи з більшим `z-index` накладаються поверх елементів з меншим значенням.

- **Особливості:**

1. Тільки для позиційованих елементів: `z-index` працює, якщо елемент має `position`: `relative`, `absolute`, `fixed` або `sticky`. Без цього `z-index` ігнорується.

2. Значення за замовчуванням: Якщо `z-index` не задано, значення за замовчуванням — `auto`. У такому випадку порядок накладання визначається порядком у DOM.

3. Може бути від’ємним: Елементи з від’ємним `z-index` можуть накладатися позаду батьківських елементів.

- Приклад:

  ```css
  .div1 {
    position: relative;
    z-index: 10; /* цей елемент буде поверх */
  }

  .div2 {
    position: relative;
    z-index: 5; /* цей елемент буде під div1 */
  }
  ```

</details>

<details>
<summary>17. Які переваги і недоліки використання CSS-препроцесорів?</summary>

#### CSS

- **Переваги CSS-препроцесорів:**

1. **Змінні:** Легко створювати глобальні змінні для кольорів, шрифтів, розмірів.

   ```css
   $primary-color: #3498db;

   body {
     color: $primary-color;
   }
   ```

2. **Вкладеність:** Зручний запис стилів для вкладених елементів.

   ```css
   nav {
     ul {
       li {
         a {
           color: #000;
         }
       }
     }
   }
   ```

3. **Міксіни:** Повторно використовувані блоки коду.

   ```css
   @mixin flex-center {
     display: flex;
     justify-content: center;
     align-items: center;
   }

   div {
     @include flex-center;
   }
   ```

4. **Функції:** Обчислення прямо в стилях.

   ```css
   width: calc(100% - 50px);
   ```

5. **Управління кодом:** Імпорт окремих файлів (`@import`), що полегшує підтримку великого проекту.

- **Недоліки CSS-препроцесорів:**

1. **Складність налаштування:** Потрібно встановлювати додаткові інструменти (наприклад, компілятор для SCSS або LESS).

2. **Продуктивність:** Велика кількість вкладеностей або міксінів може ускладнити генерований CSS і вплинути на швидкість.

3. **Залежність:** Знання синтаксису препроцесора необов'язково підтримується усіма розробниками в команді.

4. **Дебагінг:** Згенерований CSS може бути складніше дебажити, якщо немає source maps.

- Використання залежить від розміру проекту та необхідності складних стилів. Для великих проектів переваги переважують недоліки.

</details>

<details>
<summary>18. Для чого існують різні рівні заголовків, якщо розмір можна встановити стилями?</summary>

#### CSS

- Рівні заголовків (`<h1> – <h6>`) мають інше призначення, окрім визначення розміру. Їхня основна функція — структуризація контенту для семантики та доступності:

1. **Семантика:** Заголовки формують ієрархію документа. Наприклад:

`<h1>` — головна тема сторінки.
`<h2>` — підрозділ теми `<h1>`.
`<h3>` — підрозділ `<h2>`, і так далі.

2. **SEO:** Пошукові системи (Google, Bing) використовують заголовки для розуміння структури і змісту сторінки. Коректна ієрархія заголовків підвищує релевантність сторінки.

3. **Доступність:** Екранні читачі для людей із порушеннями зору використовують заголовки для навігації по сторінці.

4. **Стандарти:** Використання заголовків за призначенням робить код зрозумілим для інших розробників.

- Розмір заголовків можна стилізувати за допомогою CSS, але правильне використання тегів забезпечує краще розуміння і роботу сторінки.

</details>

<details>
<summary>19. Які є варіанти позиціонування елемента на сторінці?</summary>

#### CSS

- У CSS є кілька варіантів позиціонування елементів:

1. `static` (за замовчуванням):
   Елемент розташовується в потоці документа відповідно до порядку в HTML. Немає можливості змінювати його положення через властивості top, right, bottom, left.

2. `relative`:
   Елемент залишається в потоці документа, але його положення можна змінити відносно початкової позиції за допомогою top, right, bottom, left.

3. `absolute`:
   Елемент вилучається з потоку і позиціонується відносно найближчого батьківського елемента з позиціюванням (relative, absolute, fixed). Якщо такого немає, то відносно всього документа.

4. `fixed`:
   Елемент вилучається з потоку і закріплюється відносно вікна браузера. Його положення не змінюється при прокручуванні сторінки.

5. `sticky`:
   Комбінація relative і fixed. Елемент позиціонується відносно потоку документа, поки не досягне заданого порогу (top, bottom тощо), після чого "прилипає" до цього порогу при прокручуванні.

6. `inherit`, `initial`, `unset`:

- inherit — наслідує значення від батьківського елемента.
- initial — скидає до значення за замовчуванням (static).
- unset — застосовує inherit або initial залежно від контексту.

- Кожен варіант використовується залежно від завдання: від базового розташування до складного позиціонування в макетах.

</details>

<details>
<summary>20. Які бувають види display? Який використовуєте найчастіше? У чому особливість inline-block?</summary>

#### CSS

- Основні види display в CSS:

1. `block`:

   - Елемент займає всю ширину батьківського контейнера.
   - Починається з нового рядка.
   - Можна задавати ширину, висоту, внутрішні/зовнішні відступи.
   - Приклад: `<div>`, `<p>`.

2. `inline`:

   - Елемент розташовується в одному рядку з іншими елементами.
   - Неможливо задавати ширину та висоту.
   - Відступи (margin/padding) впливають лише на внутрішній простір.
   - Приклад: `<span>`, `<a>`.

3. `inline-block`:

   - Поєднує особливості block і inline.
   - Елемент розташовується в рядку, але дозволяє задавати ширину, висоту, відступи.
   - Зручний для створення кнопок, тегів.

4. `flex`:

   - Відображає елемент як контейнер для гнучкого компонування дочірніх елементів.
   - Використовується для вирівнювання та розподілу простору між елементами.

5. `grid`:

   - Задає контейнер для компонування в двовимірній сітці.
   - Зручний для складних макетів.

6. `none`:

   - Елемент не відображається на сторінці.

7. `inline-flex` / `inline-grid`:

   - Аналогічні flex і grid, але зберігають властивості inline.

8. `table` / `table-row` / `table-cell`:

   - Елементи імітують поведінку таблиць HTML.

- **Найчастіше використовується:**

  - block, inline-block, flex, і grid — залежно від завдань.
  - inline-block популярний для створення кнопок або елементів меню, які потрібно розташувати в рядок, але контролювати їх розміри.

- **Особливість inline-block:**

  - Елементи розташовуються в рядок, як inline, але поводяться як block, дозволяючи задавати ширину, висоту, та всі відступи.
  - Проблема: між елементами може з’явитися проміжок (через пробіли в HTML).

- Виправляється:
  - Видаленням пробілів у коді.
  - Встановленням font-size: 0 для батьківського контейнера.

</details>

<details>
<summary>21. Що таке CSS-правило?</summary>

#### CSS

- CSS-правило складається з селектора та блоку декларацій. Селектор визначає, до яких елементів на сторінці застосовуються стилі, а блок декларацій містить властивості та їх значення, що визначають вигляд цих елементів. Наприклад:

```css
p {
  color: red;
  font-size: 16px;
}
```

- Тут `p` — селектор (вибирає всі абзаци), а в блоці декларацій вказано, що текст буде червоним і розмір шрифту 16px.

</details>

<details>
<summary>22. Варіанти додавання CSS стилів на сторінку?</summary>

#### CSS

1. **Inline CSS:** Стилі додаються безпосередньо до HTML елементів через атрибут `style`.

```html
<p style="color: red; font-size: 16px;">Text</p>
```

2. **Internal CSS:** Стилі додаються в `<style>` тег в межах `<head>` секції HTML документа.

```html
<style>
  p {
    color: red;
    font-size: 16px;
  }
</style>
```

3. **External CSS:** Стилі прописуються в окремому CSS файлі, який підключається до HTML через тег `<link>`.

```html
<link rel="stylesheet" href="styles.css" />
```

- Ці варіанти відрізняються за пріоритетом і зручністю для масштабування проектів.

</details>

<details>
<summary>23. Типи позиціонування у CSS?</summary>

#### CSS

1. **static:** За замовчуванням для всіх елементів. Елементи розташовуються в нормальному потоці документа (тобто, згідно з їх порядком у HTML).

2. **relative:** Елемент розташовується відносно його початкового положення в потоці. Можна використовувати властивості `top`, `right`, `bottom`, `left`.

3. **absolute:** Елемент позиціонується відносно найближчого батьківського елемента з позиціонуванням (не `static`). Якщо такого немає, то відносно документа.

4. **fixed:** Елемент позиціонується відносно вікна браузера, тобто він залишатиметься на тому ж місці при прокручуванні сторінки.

5. **sticky:** Елемент поводиться як relative до певного моменту, після чого стає fixed, коли прокручують сторінку до заданого порогу.

</details>

<details>
<summary>24. Блокова модель CSS?</summary>

#### CSS

- Блокова модель CSS (Box Model) описує, як елементи розташовуються на веб-сторінці та як обчислюються їх розміри. Вона включає такі компоненти:

1. **Content (Контент):** Це основна частина елемента, де міститься текст або інші медіа. Розміри контенту визначаються властивостями `width` і `height`.

2. **Padding (Відступи):** Простір між контентом і межами елемента (border). Відступи додаються всередині елемента. Властивості: `padding-top`, `padding-right`, `padding-bottom`, `padding-left`.

3. **Border (Межа):** Лінія, яка оточує елемент. Може мати товщину, стиль та колір. Властивості: `border-width`, `border-style`, `border-color`.

4. **Margin (Зовнішній відступ):** Простір між елементом і його сусідніми елементами. Відступи додаються зовні елемента. Властивості: `margin-top`, `margin-right`, `margin-bottom`, `margin-left`.

- Коли вказуються розміри елемента через `width` і `height`, вони зазвичай враховують тільки `content`, але при додаванні `padding`, `border` і `margin`, розміри елемента змінюються.

- Важливо знати, що властивість `box-sizing` дозволяє визначати, як враховуються ці величини при обчисленні розмірів елемента:

  - `content-box` (за замовчуванням): розміри елемента — це тільки контент.

  - `border-box`: розміри елемента враховують також `padding` та `border`.

</details>

<details>
<summary>25. Що таке селектор? І які селектори є?</summary>

#### CSS

- **Селектор** у CSS — це частина правила, яка визначає, до яких елементів на сторінці застосовуються стилі. Селектори дозволяють вибирати HTML елементи для застосування стилів.

#### Основні типи селекторів:

1. **Типовий селектор (Type selector):** Вибирає елементи за їх тегом.

```css
p {
  color: red;
}
```

2. **Класовий селектор (Class selector):** Вибирає елементи за класом, починається з крапки.

```css
.my-class {
  color: blue;
}
```

3. **Ідентифікатор (ID selector):** Вибирає елементи за ідентифікатором, починається з решітки.

```css
#my-id {
  color: green;
}
```

4. **Атрибутний селектор (Attribute selector):** Вибирає елементи за значенням їх атрибутів.

```css
input[type="text"] {
  border: 1px solid black;
}
```

5. **Псевдоклас (Pseudo-class selector):** Вибирає елементи, що знаходяться в певному стані.

```css
a:hover {
  color: red;
}
```

6. **Псевдоелемент (Pseudo-element selector):** Вибирає частини елементів, наприклад, перший рядок або першу літеру.

```css
p::first-letter {
  font-size: 2em;
}
```

7. **Комбінатори (Combinators):**

- **_Descendant_** (потомок): Вибирає елементи, які є нащадками іншого елемента.

```css
div p {
  color: purple;
}
```

- **_Child_** (прямий нащадок): Вибирає елементи, що є прямими дітьми іншого елемента.

```css
div > p {
  color: yellow;
}
```

- **_Adjacent sibling_** (сусід): Вибирає елемент, який йде безпосередньо після іншого.

```css
h1 + p {
  margin-top: 0;
}
```

- **_General sibling_** (загальний сусід): Вибирає елементи, які є сусідами певного елемента.

```css
h1 ~ p {
  color: orange;
}
```

Це основні типи селекторів, що використовуються для вибору та стилізації елементів.

</details>

<details>
<summary>26. Різниця між Reset.css та Normalize.css?</summary>

#### CSS

- **Reset.css** і **Normalize.css** — це два різні підходи до управління стилями за замовчуванням у браузерах, але з різними цілями:

1. **Reset.css:**

- **Мета:** Видалити всі стилі браузера (включаючи відступи, поля, шрифти тощо), щоб почати з "чистого аркуша".

- **Результат:** Все, що за замовчуванням задається браузером, скидається, і елементи стають однаковими в усіх браузерах. Це часто призводить до того, що потрібно вручну додавати стилі для базових елементів.

- **Приклад:**

```css
* {
  margin: 0;
  padding: 0;
  border: 0;
}
```

2. **Normalize.css:**

- **Мета:** Зробити стилі браузерів більш однаковими, але не скидаючи їх повністю. Підтримує стандартні стилі для елементів, щоб забезпечити однаковий вигляд у всіх браузерах.

- **Результат:** Зберігаються деякі стилі за замовчуванням, але вони нормалізуються для забезпечення консистентності між різними браузерами (наприклад, вирівнювання шрифтів, списки, таблиці).

- **Приклад:**

```css
h1 {
  font-size: 2em;
  margin: 0.67em 0;
}
```

- **Основна різниця:** Reset.css скидає всі стилі браузера до мінімуму, тоді як Normalize.css підтримує базові стилі, але нормалізує їх для більшої узгодженості між браузерами.

</details>

<details>
<summary>27. Різниця між display: none та visibility: hidden?</summary>

#### CSS

`display: none` і `visibility: hidden` приховують елементи, але працюють по-різному:

- `display: none`

  - Елемент зникає повністю зі сторінки.
  - Він не займає місця в макеті.
  - Інші елементи зміщуються так, ніби його не існувало.
  - Події (наприклад, кліки) не спрацьовують на ньому.
  - Використовується для повного приховування елементів.

```css
.hidden {
  display: none;
}
```

- `visibility: hidden`

  - Елемент залишається на сторінці, але стає невидимим.
  - Він продовжує займати місце в макеті.
  - Інші елементи не зміщуються.
  - Події (наприклад, кліки) не спрацьовують, хоча елемент все ще є в DOM.

```css
.hidden {
  visibility: hidden;
}
```

**Різниця:** `display: none` прибирає елемент повністю, а `visibility: hidden` залишає його місце, але робить невидимим.

</details>

<details>
<summary>28. Різниця між блоковим та інлайновим елементами?</summary>

#### CSS

- **Блокові (block) та інлайнові (inline) елементи** відрізняються способом відображення та впливом на структуру сторінки.

#### Блокові елементи (display: block)

- Починаються з нового рядка.
- Автоматично займають всю доступну ширину (по горизонталі).
- Можуть містити як інші блокові, так і інлайнові елементи.
- Підтримують width, height, margin, padding.

**Приклади:** `<div>`, `<p>`, `<h1>-<h6>`, `<section>`, `<article>`, `<form>`, `<header>`, `<footer>`

```css
div {
  display: block;
  width: 100%;
}
```

#### Інлайнові елементи (display: inline)

- Не починаються з нового рядка, розташовуються "в потоці" тексту.
- Ширина та висота залежать від вмісту.
- width і height ігноруються (не можна змінювати вручну).
- margin та padding працюють тільки по горизонталі.

**Приклади:** `<span>`, `<a>`, `<strong>`, `<em>`, `<b>`, `<i>`

```css
span {
  display: inline;
  color: red;
}
```

#### Різниця

- Блокові елементи займають всю ширину і формують окремий рядок.
- Інлайнові елементи залишаються в потоці тексту та займають рівно стільки місця, скільки потрібно їх вмісту.

</details>

<details>
<summary>29. Різниця між класом та ідентифікатором у CSS?</summary>

#### CSS

#### Клас (`class`) vs Ідентифікатор (`id`) у CSS

| Параметр              | Клас (`class`)                            | Ідентифікатор (`id`)                      |
| --------------------- | ----------------------------------------- | ----------------------------------------- |
| Синтаксис             | Починається з `.`                         | Починається з `#`                         |
| Призначення           | Використовується для групи елементів      | Призначається одному унікальному елементу |
| Повторне використання | Може застосовуватися до кількох елементів | Повинен бути унікальним на сторінці       |
| Пріоритет у CSS       | Менший (0,0,1,0)                          | Вищий (0,1,0,0)                           |
| HTML приклад          | `<div class="box"></div>`                 | `<div id="unique-box"></div>`             |
| CSS приклад           | `.box { color: red; }`                    | `#unique-box { color: blue; }`            |

#### Різниця

- Класи використовуються для стилізації кількох елементів.
- ID застосовується до одного унікального елемента (але можна порушити це правило).
- ID має вищий пріоритет, тому його важко перевизначити.
- Класи краще використовувати для стилізації, ID — для JavaScript або унікальної ідентифікації.

</details>

<details>
<summary>30. Що таке CSS спрайт? І для чого він використовується?</summary>

#### CSS

- CSS спрайт — це техніка, де кілька зображень об'єднуються в одне велике зображення, а потім через CSS задаються позиції фону для відображення різних частин цього зображення.

Використовується для зменшення кількості HTTP-запитів, що підвищує швидкість завантаження сторінки. Зазвичай застосовується для іконок, кнопок або інших маленьких зображень, що використовуються на сайті.

#### Ось приклад використання CSS спрайту:

1. **Створення спрайта:** У вас є декілька маленьких зображень (наприклад, іконки), які ви об'єднуєте в один великий файл sprite.png.

2. **CSS для використання спрайта:**

```css
.icon {
  width: 50px;
  height: 50px;
  background-image: url("sprite.png");
  display: inline-block;
}

.icon-facebook {
  background-position: 0 0; /* Перша іконка в спрайті */
}

.icon-twitter {
  background-position: -50px 0; /* Друга іконка в спрайті */
}

.icon-linkedin {
  background-position: -100px 0; /* Третя іконка в спрайті */
}
```

3. **HTML для іконок:**

```html
<div class="icon icon-facebook"></div>
<div class="icon icon-twitter"></div>
<div class="icon icon-linkedin"></div>
```

У цьому прикладі всі іконки завантажуються з одного файлу sprite.png, і за допомогою CSS background-position визначається, яка частина спрайту відображатиметься для кожної іконки.

- Цей підхід вже не використовуеться в CSS, але для себе знати треба. 📝

</details>

<details>
<summary>31. Що таке вендорні префікси? І навіщо вони використовуються?</summary>

#### CSS

- Вендорні префікси — це спеціальні префікси, які додаються до CSS властивостей для забезпечення підтримки нових або експериментальних функцій у різних браузерах. Вони використовуються, коли властивість або функція ще не є стандартом або коли браузери реалізують їх по-своєму.

#### Приклад вендорних префіксів:

```css
.element {
  -webkit-transform: rotate(
    45deg
  ); /* для браузерів на WebKit, таких як Chrome, Safari */
  -moz-transform: rotate(45deg); /* для Firefox */
  -ms-transform: rotate(45deg); /* для Internet Explorer */
  transform: rotate(45deg); /* стандартна властивість */
}
```

- Вендорні префікси використовуються для забезпечення сумісності з різними браузерами, поки властивість не стане частиною офіційного стандарту CSS. Вони допомагають тестувати нові функції та забезпечують їх роботу на більшій кількості браузерів, поки всі вони не впровадять підтримку стандартних властивостей.

</details>

<details>
<summary>32. Що таке псевдоелементи? І навіщо вони використовуються?</summary>

#### CSS

- Псевдоелементи — це конструкції в CSS, які дозволяють стилізувати частини елементів, які не мають власного HTML представлення. Вони дозволяють додавати стилі до таких частин елементів, як перший рядок тексту, вміст перед або після елемента, або створення декоративних елементів без необхідності змінювати HTML.

#### Основні псевдоелементи:

- `::before` — додає вміст перед елементом.
- `::after` — додає вміст після елемента.
- `::first-letter` — стилізує першу букву тексту в елементі.
- `::first-line` — стилізує перший рядок тексту в елементі.

**Приклад використання:**

```css
p::before {
  content: "🔹 ";
}

p::after {
  content: " 🔸";
}

p::first-letter {
  font-size: 2em;
  color: red;
}
```

**Застосування:** Псевдоелементи використовуються для:

- Додавання декоративних елементів без зміни HTML.
- Створення візуальних ефектів (наприклад, стилізація першої літери або першого рядка).
- Додавання контенту перед або після елемента, наприклад, іконок або текстових маркерів, без необхідності додавати додаткові теги в HTML.

</details>

<details>
<summary>33. Що таке схлопування меж (margin collapsing)?</summary>

#### CSS

- Схлопування меж (margin collapsing) — це явище в CSS, коли вертикальні відступи (margins) між сусідніми блоками або елементами "зливаються" в один, замість того, щоб відображатися окремо.

**Це зазвичай відбувається в таких ситуаціях:**

1. Коли два сусідні блоки мають вертикальні відступи (margins).

2. Коли один блок має відступ, а наступний блок не має відступу або його margin значення нульове.

У результаті, між елементами відображається відстань, що дорівнює найбільшому з цих відступів.

**Приклад:**

```html
<div style="margin-bottom: 20px;">Block 1</div>
<div style="margin-top: 10px;">Block 2</div>
```

- У цьому випадку схлопування меж призведе до того, що відстань між блоками буде 20px, а не 30px (як можна було б очікувати при додаванні 20px + 10px).

- **Чому це відбувається?** Схлопування меж застосовується, щоб уникнути зайвих відступів і зробити верстку більш зручною для використання, оскільки зазвичай не має сенсу мати два відступи, що діють на ту саму частину простору.

**Як уникнути схлопування:**

- Використовувати `padding`, а не `margin`, якщо потрібно уникнути схлопування.
- Встановити `overflow` на елементі.
- Використовувати фонові або градієнтні елементи, щоб блокувати схлопування.

</details>

<details>
<summary>34. Що таке z-index? Як формується контекст накладання?</summary>

#### CSS

- `z-index` — це CSS властивість, яка визначає порядок накладання елементів на сторінці. Вона використовується для визначення, який елемент має бути поверх іншого, коли елементи перекривають один одного. Вищий `z-index` означає, що елемент буде накладатися поверх елементів з нижчим значенням `z-index`.

#### Як працює `z-index`:

- Значення `z-index` може бути цілим числом (наприклад, 1, 10, -5).

- За замовчуванням, елементи з однаковим `z-index` або без нього накладаються один на одного в порядку їх появи в HTML.

- Чим більше значення `z-index`, тим вище елемент буде на сторінці.

#### Приклад:

```css
div {
  position: absolute;
}

.div1 {
  z-index: 1;
}

.div2 {
  z-index: 2;
}
```

- У цьому прикладі `.div2` буде накладатися поверх `.div1`, оскільки у неї вищий `z-index`.

#### Контекст накладання:

Контекст накладання — це область, в межах якої визначаються всі значення z-index для елементів. Це стосується елементів з властивістю position (не static), або коли застосовуються інші властивості, які створюють новий контекст накладання.

- **Контекст накладання формується, коли:**

1. Елемент має властивість `position` з одним із значень (`relative`, `absolute`, `fixed`, `sticky`).
2. `z-index` встановлено на значення, відмінне від auto.
3. Властивість opacity менша за 1.
4. Властивість `transform`, `filter`, `perspective`, `clip-path` та інші створюють новий контекст.

- **Як формується контекст накладання:**

1. Вищезгадані умови (наприклад, `position: relative` і `z-index`).
2. Ті елементи, які знаходяться в цьому контексті, будуть порівнювати свої z-index тільки в межах цього контексту, а не з іншими елементами на сторінці.
3. Якщо елемент знаходиться в різних контекстах накладання, то порівнювати z-index можна лише в межах кожного з контекстів.

#### Приклад контексту накладання:

```html
<div class="parent" style="position: relative; z-index: 10;">
  <div class="child" style="position: absolute; z-index: 5;">Child 1</div>
  <div class="child" style="position: absolute; z-index: 15;">Child 2</div>
</div>

<div class="sibling" style="position: absolute; z-index: 20;">Sibling</div>
```

- У цьому прикладі:

  - `.child 1` і `.child 2` знаходяться в одному контексті накладання всередині `.parent`.
  - `.sibling` має інший контекст накладання і з'явиться поверх обох `.child`, оскільки має більший `z-index` у своєму контексті.

</details>

<details>
<summary>35. Порядок накладання елементів у CSS (Stacking Order)?</summary>

#### CSS

- Порядок накладання елементів у CSS (Stacking Order) визначається порядком, у якому елементи накладаються один на одного на сторінці. Це важливо, коли елементи з різними властивостями (наприклад, `z-index`) можуть перекривати один одного.

#### Порядок накладання (Stacking Order):

1. **Елементи за замовчуванням** (статичні елементи, без позиціонування та без `z-index`):

- Елементи без позиціонування (`position: static` або без властивості `position`) розташовуються один за одним у порядку їхнього розташування в HTML.

2. **Елементи з позиціонуванням** (`relative`, `absolute`, `fixed`, `sticky`):

- Якщо елемент має будь-яке інше значення `position` (крім `static`), він створює новий контекст накладання. У межах цього контексту елементи з більшим значенням `z-index` будуть накладатися поверх елементів з меншим значенням.

3. **Елементи з z-index**:

- Елементи з більш високим `z-index` будуть розташовуватися поверх елементів з нижчим значенням `z-index` (якщо елементи знаходяться в одному контексті накладання).

4. **Невидимі елементи** (з `opacity` менше 1 або з `visibility: hidden`):

- Елементи, які мають властивість `opacity` менше 1 або `visibility: hidden`, можуть бути розташовані поверх інших елементів, але їх все одно не видно.

5. **Елементи з властивістю** `transform`, `filter`, `perspective`, `clip-path` та іншими, що створюють новий контекст накладання:

- Коли елемент має одну з цих властивостей, це створює новий контекст накладання, і елементи в цьому контексті будуть накладатися згідно з їхніми значеннями `z-index`, незалежно від того, де вони знаходяться на сторінці.

6. **Елементи з фонового вмісту** (`backgrounds`, `borders`, etc.):

- Вміст, такий як фон або бордери, не створює власного контексту накладання, але може бути важливим для визначення, як інші елементи накладаються.

#### Порядок накладання елементів за замовчуванням:

1. **Блоки без позиціонування** (статичні елементи).

2. **Елементи з позиціонуванням** `relative` (якщо не визначено `z-index`).

3. **Елементи з позиціонуванням** `absolute`, `fixed`, `sticky` (в залежності від `z-index`).

4. **Нове контексти накладання** (наприклад, елементи з `transform`, `opacity < 1`, `filter` тощо).

#### Простіше кажучи:

- Статичні елементи не створюють контексту накладання і накладаються в порядку їхнього розташування в HTML.

- Елементи з позиціонуванням `relative`, `absolute`, `fixed`, `sticky` створюють контекст накладання, де `z-index` визначає, які елементи будуть поверх інших.

- Елементи з новими контекстами накладання (наприклад, з `transform` або `opacity < 1`) накладаються поверх всіх інших елементів із меншим пріоритетом.

</details>

<details>
<summary>36. Як за допомогою CSS визначити, чи підтримується властивість у браузері?</summary>

#### CSS

- Для того, щоб перевірити, чи підтримується властивість у браузері, в CSS безпосередньо неможливо це зробити, оскільки CSS сам по собі не має вбудованих механізмів для перевірки підтримки властивостей. Однак, є кілька способів зробити це за допомогою JavaScript та умовних конструкцій у CSS.

1. **Використання JavaScript (Modernizr)**

Один із способів перевірити, чи підтримується CSS властивість у браузері — це використати JavaScript-бібліотеку, наприклад, Modernizr. Modernizr дозволяє перевіряти підтримку різних технологій і властивостей браузером.

**Приклад використання Modernizr:**

```javascript
if (Modernizr.flexbox) {
  console.log("Flexbox підтримується!");
} else {
  console.log("Flexbox не підтримується.");
}
```

2. **Використання умови @supports в CSS**

CSS має власну конструкцію `@supports`, яка дозволяє перевіряти, чи підтримується певна CSS властивість або її значення в поточному браузері.

**Приклад:**

```css
/* Перевіряє, чи підтримується flexbox */
@supports (display: flex) {
  .container {
    display: flex;
  }
}

/* Якщо не підтримується flexbox, додається альтернативне значення */
@supports not (display: flex) {
  .container {
    display: block;
  }
}
```

У цьому прикладі, якщо браузер підтримує `display: flex`, то він застосує стилі, визначені в першому блоці. Якщо ж не підтримує, застосує стилі з блоку `@supports` not.

3. **Використання префіксів для застарілих властивостей**

Для старих властивостей або експериментальних властивостей браузерів часто використовуються вендорні префікси. Якщо необхідно працювати з такими властивостями, часто можна додавати ці префікси та перевіряти, чи працює код на різних браузерах.

**Приклад з вендорними префіксами:**

```css
/* Вендорні префікси для трансформацій */
.element {
  -webkit-transform: rotate(45deg);
  -moz-transform: rotate(45deg);
  transform: rotate(45deg);
}
```

Це допоможе забезпечити сумісність з різними версіями браузерів.

#### Висновок

Найбільш зручним методом перевірки підтримки властивості є використання @supports у CSS або бібліотеки Modernizr для JavaScript, яка дозволяє створити перевірки підтримки за допомогою скриптів.

</details>

<details>
<summary>37. Глобальні ключові слова у CSS?</summary>

#### CSS

- Глобальні ключові слова в CSS — це спеціальні значення, які можна задати будь-якій CSS-властивості. Вони не змінюють саме значення властивості, а вказують, як її слід обчислювати.

#### Список глобальних ключових слів

1. `inherit` – успадковує значення від батьківського елемента.
2. `initial` – скидає значення до дефолтного (згідно зі специфікацією).
3. `unset` – якщо властивість успадковується за замовчуванням (наприклад, color), діє як inherit, інакше – як initial.
4. `revert` – повертає значення до того, що визначено у стилях браузера чи користувача.
5. `revert-layer` – скидає значення до попереднього рівня каскаду (актуально для @layer).

#### Приклади використання

✅ `inherit` (успадкування значення)

```css
p {
  color: red;
}
span {
  color: inherit; /* отримає червоний від <p> */
}
```

✅ `initial` (повернення до стандартного значення)

```css
button {
  all: initial; /* скидає всі властивості до дефолтних */
}
```

✅ `unset` (залежно від властивості)

```css
div {
  color: unset; /* успадкує */
  width: unset; /* повернеться до `auto` */
}
```

✅ `revert` (повернення до стандартних стилів браузера)

```css
a {
  color: green;
}
a.special {
  color: revert; /* поверне синій, якщо його задає браузер */
}
```

✅ `revert-layer` (актуально для @layer)

```css
@layer framework {
  button {
    background: red;
  }
}

@layer custom {
  button {
    background: blue;
  }
}

/* revert-layer поверне червоний із framework, а не дефолтний */
button {
  background: revert-layer;
}
```

#### Висновок

- `inherit` – для спадкування.
- `initial` – для скидання до дефолту.
- `unset` – комбінує inherit та initial.
- `revert` – повертає значення браузера чи стилів користувача.
- `revert-layer` – скидає значення до попереднього рівня каскаду.

</details>

<details>
<summary>38. Що таке перерахування селекторів?</summary>

#### CSS

- Перерахування селекторів — це використання кількох селекторів, розділених комою, для одночасного застосування стилів до різних елементів.

#### Синтаксис

```css
selector1,
selector2,
selector3 {
  property: value;
}
```

#### Приклади

✅ Стилізація кількох елементів одночасно

```css
h1,
h2,
h3 {
  color: red;
}
```

- Усі h1, h2 і h3 стануть червоними.

✅ Комбінація класів і тегів

```css
button,
.btn {
  padding: 10px;
}
```

- Застосується до `<button>` і будь-якого елемента з `.btn`.

✅ Перерахування складних селекторів

```css
.card .title,
.box .header {
  font-weight: bold;
}
```

- Стилізує `.title` всередині `.card` і `.header` всередині `.box`.

#### Висновок

- Коми (`,`) об'єднують селектори, застосовуючи однакові стилі.
- Дозволяє скорочувати код і зменшувати дублювання.
- Важливо не плутати з комбінованими селекторами (наприклад, `.class1 .class2`, де `.class2` має бути всередині `.class1`).

</details>

<details>
<summary>39. Для чого використовується ключове слово currentColor у CSS?</summary>

#### CSS

- `currentColor` — це ключове слово в CSS, яке задає значення кольору (`color`) для інших властивостей, що підтримують кольори.

#### Як працює

- `currentColor` автоматично використовує значення, встановлене у властивості `color`.

#### Приклади використання

✅ Однаковий колір для тексту та рамки

```css
button {
  color: blue;
  border: 2px solid currentColor;
}
```

- Рамка кнопки буде того ж кольору, що й текст (`blue`).

✅ SVG-іконки із кольором тексту

```css
.icon {
  color: red;
  fill: currentColor;
}
```

- `fill` у SVG прийме `color` елемента (`red`).

✅ Прозорість зі спадкуванням кольору

```css
.link {
  color: green;
  background: linear-gradient(currentColor 0%, transparent 100%);
}
```

- Градієнт стартує від `green`, бо це значення `color`.

#### Висновок

- Використовує значення `color`, усуваючи дублювання стилів.
- Особливо корисно для SVG, `border`, `background`, `box-shadow`.
- Спрощує темізацію: змінюєш `color`, і все підлаштовується.

</details>

<details>
<summary>40. Які псевдокласи є CSS?</summary>

#### CSS

#### Псевдокласи в CSS

- ✅ Динамічні псевдокласи

| Псевдоклас | Опис                                         |
| ---------- | -------------------------------------------- |
| `:hover`   | При наведенні курсору.                       |
| `:focus`   | Коли елемент у фокусі (наприклад, `input`).  |
| `:active`  | Під час натискання.                          |
| `:visited` | Для відвіданих посилань.                     |
| `:target`  | Для елемента, що відповідає `#anchor` в URL. |

- ✅ Структурні псевдокласи

| Псевдоклас           | Опис                                                   |
| -------------------- | ------------------------------------------------------ |
| `:first-child`       | Перший дочірній елемент.                               |
| `:last-child`        | Останній дочірній елемент.                             |
| `:nth-child(n)`      | Дочірній елемент за індексом `n` (можна `odd`/`even`). |
| `:nth-last-child(n)` | Те саме, але з кінця.                                  |
| `:only-child`        | Якщо елемент єдиний у батьківському контейнері.        |

- ✅ Типові псевдокласи

| Псевдоклас             | Опис                                         |
| ---------------------- | -------------------------------------------- |
| `:first-of-type`       | Перший елемент певного типу.                 |
| `:last-of-type`        | Останній елемент певного типу.               |
| `:nth-of-type(n)`      | N-ий елемент певного типу.                   |
| `:nth-last-of-type(n)` | N-ий елемент певного типу з кінця.           |
| `:only-of-type`        | Якщо елемент унікальний серед такого ж типу. |

- ✅ Логічні псевдокласи

| Псевдоклас         | Опис                                                 |
| ------------------ | ---------------------------------------------------- |
| `:not(selector)`   | Вибирає все, **крім** вказаного селектора.           |
| `:has(selector)`   | Вибирає елементи, що містять інший елемент (`CSS4`). |
| `:where(selector)` | Як `:is()`, але без пріоритету.                      |
| `:is(selector)`    | Спрощує складні селектори.                           |

- ✅ Псевдокласи для форм

| Псевдоклас    | Опис                                |
| ------------- | ----------------------------------- |
| `:checked`    | Позначений чекбокс або радіокнопка. |
| `:disabled`   | Вимкнений елемент форми.            |
| `:enabled`    | Активний елемент форми.             |
| `:required`   | Поле `input`, що обов’язкове.       |
| `:optional`   | Поле `input`, що не є обов’язковим. |
| `:valid`      | Поле форми з коректним значенням.   |
| `:invalid`    | Поле форми з некоректним значенням. |
| `:read-only`  | Поле у режимі `readonly`.           |
| `:read-write` | Поле, що можна редагувати.          |

**Псевдокласи допомагають стилізувати елементи без додаткових класів або JS. Використовуйте `:is()` та `:has()` для скорочення складних селекторів у CSS4.**

</details>

<details>
<summary>41. Які фільтри є у CSS?</summary>

#### CSS

- Фільтри у CSS

Фільтри (`filter`) дозволяють змінювати вигляд елементів, застосовуючи ефекти до їхнього рендерингу.

#### 🔹 Основні фільтри

| Фільтр          | Опис                                                  | Приклад                     |
| --------------- | ----------------------------------------------------- | --------------------------- |
| `blur(px)`      | Розмиття з вказаним радіусом у пікселях.              | `filter: blur(5px);`        |
| `brightness(%)` | Змінює яскравість (100% – без змін).                  | `filter: brightness(150%);` |
| `contrast(%)`   | Змінює контраст (100% – без змін).                    | `filter: contrast(120%);`   |
| `grayscale(%)`  | Відтінки сірого (100% – чорно-біле).                  | `filter: grayscale(100%);`  |
| `invert(%)`     | Інвертує кольори (100% – повністю інвертоване).       | `filter: invert(100%);`     |
| `opacity(%)`    | Прозорість (0% – повністю прозоре, 100% – непрозоре). | `filter: opacity(50%);`     |
| `saturate(%)`   | Насиченість (100% – без змін, 0% – ч/б).              | `filter: saturate(200%);`   |
| `sepia(%)`      | Ефект сепії (100% – повністю сепія).                  | `filter: sepia(80%);`       |

#### 🔹 Фільтри для тіней та зміщення

| Фільтр                        | Опис                                                                        | Приклад                                              |
| ----------------------------- | --------------------------------------------------------------------------- | ---------------------------------------------------- |
| `drop-shadow(x y blur color)` | Додає тінь до зображення (аналог `box-shadow`, але працює з прозорими PNG). | `filter: drop-shadow(5px 5px 10px rgba(0,0,0,0.5));` |

#### 🔹 Комбінування фільтрів

- Фільтри можна комбінувати, вказуючи їх через пробіл:

```css
filter: brightness(120%) contrast(110%) blur(3px);
```

- Фільтри застосовуються до всіх елементів, але найчастіше – до зображень (img), відео та бекграундів.

</details>

<details>
<summary>42. Навіщо використовується псевдоклас :invalid?</summary>

#### CSS

- Псевдоклас `:invalid` використовується для стилізації полів вводу (`<input>`, `<textarea>`, `<select>`), які не відповідають вимогам валідації.

#### Навіщо це потрібно?

- Підсвічувати некоректно заповнені поля.
- Покращити UX, показуючи візуальний зворотний зв’язок.
- Додати кастомні стилі без JavaScript.

#### Приклад використання

```css
input:invalid {
  border: 2px solid red;
  background-color: #ffe6e6;
}
```

```html
<input type="email" required placeholder="Введіть email" />
```

- Якщо поле буде пустим або міститиме некоректний email, воно підсвітиться червоним.

</details>

<details>
<summary>43. Розкажіть про властивість display в CSS?</summary>

#### CSS

#### Властивість `display` у CSS

- `display` визначає, як елемент відображається на сторінці та як він взаємодіє з іншими елементами.

#### 🔹 Основні значення

| Значення       | Опис                                                         |
| -------------- | ------------------------------------------------------------ |
| `none`         | Елемент прихований і не займає місця в макеті.               |
| `block`        | Блочний елемент, займає всю ширину батьківського контейнера. |
| `inline`       | Вбудований елемент, займає лише необхідну ширину.            |
| `inline-block` | Вбудований елемент, але можна змінювати ширину/висоту.       |

#### 🔹 Гнучкі макети

| Значення      | Опис                                                                |
| ------------- | ------------------------------------------------------------------- |
| `flex`        | Активація **Flexbox** для гнучкого розташування дочірніх елементів. |
| `grid`        | Використання **CSS Grid** для двовимірного макету.                  |
| `inline-flex` | Flex-контейнер, але поводиться як `inline`.                         |
| `inline-grid` | Grid-контейнер, але поводиться як `inline`.                         |

#### 🔹 Табличні макети

| Значення     | Опис                           |
| ------------ | ------------------------------ |
| `table`      | Елемент поводиться як таблиця. |
| `table-row`  | Імітує рядок таблиці.          |
| `table-cell` | Імітує комірку таблиці.        |

#### 🔹 Інші значення

| Значення    | Опис                                                         |
| ----------- | ------------------------------------------------------------ |
| `list-item` | Елемент поводиться як `<li>`, додаючи маркер списку.         |
| `inherit`   | Наслідує значення `display` від батьківського елемента.      |
| `initial`   | Встановлює значення `display` за замовчуванням для браузера. |

**`display: none` повністю прибирає елемент з потоку, на відміну від `visibility: hidden`, який просто приховує його, залишаючи місце.**

</details>

<details>
<summary>44. У якому випадку краще використовувати translate() замість абсолютного позиціонування?</summary>

#### CSS

- Використовувати `translate()` краще в таких випадках:

1. **Оптимізація продуктивності** – `translate()` використовує GPU для обчислень, що робить анімації та переміщення плавнішими, ніж зміна `top/left`.

2. **Збереження потоку документа** – `translate()` не впливає на положення інших елементів, на відміну від `position: absolute`, який змінює розташування елемента відносно найближчого позиціонованого предка.

3. **Поліпшення продуктивності рендерингу** – зміна `transform` не викликає рефлоу (`reflow`), тоді як `top/left` змушують браузер перераховувати макет.

4. **Гнучке центрування** – `translate(-50%, -50%)` часто використовується для центрування без залежності від розмірів контейнера.

- Якщо потрібно перемістити елемент без зміни його поточного контексту, `translate()` – кращий вибір.

</details>

<details>
<summary>45. ???</summary>

#### CSS

- Coming Soon... 😎

</details>
